#include <windows.h>
#include <setupapi.h>
#include <iostream>
#include <vector>
#include <string>
#include <thread>
#include <atomic>
#include <chrono>
#include "../shared/AppleMagicIoctl.h"
#include "GestureEngine.h"
#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "user32.lib")

// Service constants
static const wchar_t* kServiceName = L"AppleMagicService";
static SERVICE_STATUS_HANDLE gStatusHandle = nullptr;
static std::atomic<bool> gStopFlag{ false };
static HANDLE gDeviceHandle = INVALID_HANDLE_VALUE;
static std::thread gWorkerThread;
static GestureEngine gGesture;

// Forward declarations
static HANDLE OpenAppleMagicInterface();
static void   PollLoop();
static bool   QueryParsed(HANDLE h, MAGIC_PARSED_MOUSE_REPORT_U& out);
static void   RunConsoleMode();
static void   ReportServiceStatus(DWORD state, DWORD win32Exit = NO_ERROR, DWORD waitHint = 0);
static void WINAPI ServiceCtrlHandler(DWORD ctrl);
static void WINAPI ServiceMain(DWORD argc, LPWSTR* argv);
static bool InstallService();
static bool UninstallService();

// Device enumeration (same for console + service)
static HANDLE OpenAppleMagicInterface() {
    HDEVINFO h = SetupDiGetClassDevs(&GUID_DEVINTERFACE_APPLE_MAGIC_RAW, nullptr, nullptr, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (h == INVALID_HANDLE_VALUE) return INVALID_HANDLE_VALUE;
    SP_DEVICE_INTERFACE_DATA ifData{}; ifData.cbSize = sizeof(ifData);
    for (DWORD i = 0; SetupDiEnumDeviceInterfaces(h, nullptr, &GUID_DEVINTERFACE_APPLE_MAGIC_RAW, i, &ifData); ++i) {
        DWORD needed = 0; SetupDiGetDeviceInterfaceDetail(h, &ifData, nullptr, 0, &needed, nullptr);
        if (!needed) continue;
        std::vector<char> buf(needed);
        auto detail = reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA>(buf.data());
        detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        if (!SetupDiGetDeviceInterfaceDetail(h, &ifData, detail, needed, nullptr, nullptr)) continue;
        HANDLE dev = CreateFile(detail->DevicePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
        if (dev != INVALID_HANDLE_VALUE) { SetupDiDestroyDeviceInfoList(h); return dev; }
    }
    SetupDiDestroyDeviceInfoList(h);
    return INVALID_HANDLE_VALUE;
}

static bool QueryParsed(HANDLE h, MAGIC_PARSED_MOUSE_REPORT_U& out) {
    DWORD bytes = 0;
    if (!DeviceIoControl(h, IOCTL_APPLE_MAGIC_PARSE_LAST, nullptr, 0, &out, sizeof(out), &bytes, nullptr)) return false;
    return bytes >= sizeof(out);
}

// Gesture injection helper (wheel events)
static void InjectScroll(int dx, int dy) {
    // Convert deltas into WHEEL_DELTA units (simple scaling)
    const int threshold = 30; // placeholder threshold from gesture engine
    INPUT in{}; in.type = INPUT_MOUSE;
    if (dy != 0) {
        in.mi.dwFlags = MOUSEEVENTF_WHEEL;
        in.mi.mouseData = (dy > 0 ? WHEEL_DELTA : -WHEEL_DELTA) * (abs(dy) / threshold);
        if (in.mi.mouseData != 0) SendInput(1, &in, sizeof(in));
    }
    if (dx != 0) {
        in.mi.dwFlags = MOUSEEVENTF_HWHEEL;
        in.mi.mouseData = (dx > 0 ? WHEEL_DELTA : -WHEEL_DELTA) * (abs(dx) / threshold);
        if (in.mi.mouseData != 0) SendInput(1, &in, sizeof(in));
    }
}

// Background polling loop for service / console
static void PollLoop() {
    int reconnectAttempts = 0;
    while (!gStopFlag.load()) {
        if (gDeviceHandle == INVALID_HANDLE_VALUE) {
            gDeviceHandle = OpenAppleMagicInterface();
            if (gDeviceHandle == INVALID_HANDLE_VALUE) {
                if (++reconnectAttempts % 20 == 0) std::cout << "Waiting for Apple Magic device..." << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(500));
                continue;
            }
            std::cout << "Device connected." << std::endl;
            reconnectAttempts = 0;
        }
        MAGIC_PARSED_MOUSE_REPORT_U rep{};
        if (QueryParsed(gDeviceHandle, rep)) {
            gGesture.OnParsedReport(rep, InjectScroll);
        } else {
            DWORD err = GetLastError();
            if (err == ERROR_INVALID_FUNCTION) {
                std::cout << "Driver PARSE_LAST unsupported." << std::endl;
                std::this_thread::sleep_for(std::chrono::seconds(2));
            } else if (err == ERROR_DEVICE_NOT_CONNECTED || err == ERROR_FILE_NOT_FOUND) {
                CloseHandle(gDeviceHandle); gDeviceHandle = INVALID_HANDLE_VALUE;
            } else {
                // Mild backoff on transient errors
                std::this_thread::sleep_for(std::chrono::milliseconds(50));
            }
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(8)); // ~125 Hz poll (placeholder)
    }
    if (gDeviceHandle != INVALID_HANDLE_VALUE) { CloseHandle(gDeviceHandle); gDeviceHandle = INVALID_HANDLE_VALUE; }
}

// Service support -----------------------------------------------------------
static void ReportServiceStatus(DWORD state, DWORD win32Exit, DWORD waitHint) {
    static DWORD checkPoint = 1;
    SERVICE_STATUS status{};
    status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    status.dwCurrentState = state;
    status.dwControlsAccepted = (state == SERVICE_RUNNING) ? SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN : 0;
    status.dwWin32ExitCode = win32Exit;
    status.dwWaitHint = waitHint;
    status.dwCheckPoint = (state == SERVICE_RUNNING || state == SERVICE_STOPPED) ? 0 : checkPoint++;
    if (gStatusHandle) SetServiceStatus(gStatusHandle, &status);
}

static void WINAPI ServiceCtrlHandler(DWORD ctrl) {
    if (ctrl == SERVICE_CONTROL_STOP || ctrl == SERVICE_CONTROL_SHUTDOWN) {
        ReportServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, 1000);
        gStopFlag.store(true);
    }
}

static void WINAPI ServiceMain(DWORD argc, LPWSTR* argv) {
    UNREFERENCED_PARAMETER(argc); UNREFERENCED_PARAMETER(argv);
    gStatusHandle = RegisterServiceCtrlHandler(kServiceName, ServiceCtrlHandler);
    if (!gStatusHandle) return;
    ReportServiceStatus(SERVICE_START_PENDING, NO_ERROR, 3000);

    gStopFlag.store(false);
    gWorkerThread = std::thread(PollLoop);

    ReportServiceStatus(SERVICE_RUNNING, NO_ERROR, 0);

    // Wait for stop
    gWorkerThread.join();
    ReportServiceStatus(SERVICE_STOPPED, NO_ERROR, 0);
}

static bool InstallService() {
    wchar_t path[MAX_PATH];
    if (!GetModuleFileName(nullptr, path, MAX_PATH)) return false;
    SC_HANDLE scm = OpenSCManager(nullptr, nullptr, SC_MANAGER_CREATE_SERVICE);
    if (!scm) return false;
    SC_HANDLE svc = CreateService(scm, kServiceName, kServiceName, SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, SERVICE_AUTO_START, SERVICE_ERROR_NORMAL, path, nullptr, nullptr, L"", nullptr, nullptr);
    if (!svc) { CloseServiceHandle(scm); return false; }
    SERVICE_DESCRIPTION desc{ const_cast<LPWSTR>(L"Apple Magic input gesture service (prototype)") };
    ChangeServiceConfig2(svc, SERVICE_CONFIG_DESCRIPTION, &desc);
    CloseServiceHandle(svc); CloseServiceHandle(scm);
    std::wcout << L"Service installed." << std::endl;
    return true;
}

static bool UninstallService() {
    SC_HANDLE scm = OpenSCManager(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!scm) return false;
    SC_HANDLE svc = OpenService(scm, kServiceName, DELETE | SERVICE_STOP | SERVICE_QUERY_STATUS);
    if (!svc) { CloseServiceHandle(scm); return false; }
    SERVICE_STATUS s; ControlService(svc, SERVICE_CONTROL_STOP, &s); // ignore result
    bool ok = (DeleteService(svc) != 0);
    CloseServiceHandle(svc); CloseServiceHandle(scm);
    if (ok) std::wcout << L"Service uninstalled." << std::endl;
    return ok;
}

// Console mode fallback / debug
static void RunConsoleMode() {
    std::cout << "Running in console mode. Press Ctrl+C to exit." << std::endl;
    gStopFlag.store(false);
    gWorkerThread = std::thread(PollLoop);
    // Simple wait loop
    while (!gStopFlag.load()) {
        std::this_thread::sleep_for(std::chrono::milliseconds(250));
    }
    gWorkerThread.join();
}

int wmain(int argc, wchar_t* argv[]) {
    if (argc > 1) {
        std::wstring cmd = argv[1];
        if (cmd == L"install") { return InstallService() ? 0 : 1; }
        if (cmd == L"uninstall") { return UninstallService() ? 0 : 1; }
        if (cmd == L"console") { RunConsoleMode(); return 0; }
    }

    SERVICE_TABLE_ENTRY table[] = {
        { const_cast<LPWSTR>(kServiceName), ServiceMain },
        { nullptr, nullptr }
    };
    if (!StartServiceCtrlDispatcher(table)) {
        // Not started as service; fallback to console
        RunConsoleMode();
    }
    return 0;
}
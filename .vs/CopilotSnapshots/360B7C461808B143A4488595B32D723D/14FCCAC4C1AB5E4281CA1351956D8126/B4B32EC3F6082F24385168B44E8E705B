#include <windows.h>
#include <setupapi.h>
#include <iostream>
#include <vector>
#include <string>
#include <chrono>
#include <thread>
#include "../shared/AppleMagicIoctl.h"
#pragma comment(lib, "setupapi.lib")

static HANDLE OpenAppleMagicInterface() {
    HDEVINFO h = SetupDiGetClassDevs(&GUID_DEVINTERFACE_APPLE_MAGIC_RAW, nullptr, nullptr, DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (h == INVALID_HANDLE_VALUE) return INVALID_HANDLE_VALUE;
    SP_DEVICE_INTERFACE_DATA ifData{}; ifData.cbSize = sizeof(ifData);
    for (DWORD i=0; SetupDiEnumDeviceInterfaces(h, nullptr, &GUID_DEVINTERFACE_APPLE_MAGIC_RAW, i, &ifData); ++i) {
        DWORD needed = 0; SetupDiGetDeviceInterfaceDetail(h, &ifData, nullptr, 0, &needed, nullptr);
        if (needed == 0) continue;
        std::vector<char> buf(needed);
        auto detail = reinterpret_cast<PSP_DEVICE_INTERFACE_DETAIL_DATA>(buf.data());
        detail->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
        if (!SetupDiGetDeviceInterfaceDetail(h, &ifData, detail, needed, nullptr, nullptr)) continue;
        HANDLE dev = CreateFile(detail->DevicePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
        if (dev != INVALID_HANDLE_VALUE) { SetupDiDestroyDeviceInfoList(h); return dev; }
    }
    SetupDiDestroyDeviceInfoList(h);
    return INVALID_HANDLE_VALUE;
}

static bool QueryParsed(HANDLE h, MAGIC_PARSED_MOUSE_REPORT_U &out) {
    DWORD bytes = 0;
    if (!DeviceIoControl(h, IOCTL_APPLE_MAGIC_PARSE_LAST, nullptr, 0, &out, sizeof(out), &bytes, nullptr)) return false;
    return bytes >= sizeof(out);
}

int main() {
    std::cout << "Apple Magic Service Prototype (Console)" << std::endl;
    HANDLE hDev = INVALID_HANDLE_VALUE;
    for (int retry = 0; retry < 10; ++retry) {
        hDev = OpenAppleMagicInterface();
        if (hDev != INVALID_HANDLE_VALUE) break;
        std::cout << "Waiting for device interface..." << std::endl;
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
    }
    if (hDev == INVALID_HANDLE_VALUE) {
        std::cerr << "Failed to open device interface." << std::endl; return 1; }

    std::cout << "Connected. Polling parsed reports (Ctrl+C to exit)." << std::endl;
    MAGIC_PARSED_MOUSE_REPORT_U last{};
    while (true) {
        MAGIC_PARSED_MOUSE_REPORT_U rep{};
        if (QueryParsed(hDev, rep)) {
            if (rep.ReportId != 0 || rep.Buttons || rep.DeltaX || rep.DeltaY) {
                std::cout << "RID=" << (int)rep.ReportId << " Btn=" << (int)rep.Buttons
                          << " dX=" << rep.DeltaX << " dY=" << rep.DeltaY
                          << " Cnt=" << (int)rep.ContactCount << std::endl;
            }
            last = rep;
        } else {
            DWORD err = GetLastError();
            if (err == ERROR_INVALID_FUNCTION) {
                std::cout << "Driver does not yet support PARSE_LAST." << std::endl;
                break;
            }
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    CloseHandle(hDev);
    return 0;
}
// AppleMagicFilter.c - KMDF Upper Filter for Apple Magic devices (kernel-mode)
// Captures raw HID input reports in a ring buffer and exposes IOCTLs for last raw / parsed report.
// DISCLAIMER: Educational scaffold; not production-ready.

#include "AppleMagicFilter.h"

static VOID AppleMagic_EvtIoStop(WDFQUEUE Q, WDFREQUEST R, ULONG F){UNREFERENCED_PARAMETER(Q);UNREFERENCED_PARAMETER(F);WdfRequestComplete(R, STATUS_SUCCESS);} 

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath){
    WDF_DRIVER_CONFIG cfg; WDF_OBJECT_ATTRIBUTES attr; NTSTATUS status;
    WDF_DRIVER_CONFIG_INIT(&cfg, AppleMagic_EvtDeviceAdd);
    WDF_OBJECT_ATTRIBUTES_INIT(&attr);
    status = WdfDriverCreate(DriverObject, RegistryPath, &attr, &cfg, WDF_NO_HANDLE);
    return status;
}

NTSTATUS AppleMagic_EvtDeviceAdd(WDFDRIVER Driver, PWDFDEVICE_INIT DeviceInit){
    UNREFERENCED_PARAMETER(Driver);
    WdfFdoInitSetFilter(DeviceInit);
    WDF_PNPPOWER_EVENT_CALLBACKS pnp; WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnp);
    pnp.EvtDevicePrepareHardware = AppleMagic_EvtPrepareHardware;
    WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnp);

    WDF_OBJECT_ATTRIBUTES devAttr; WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&devAttr, DEVICE_CONTEXT);
    WDFDEVICE device; NTSTATUS status = WdfDeviceCreate(&DeviceInit, &devAttr, &device);
    if(!NT_SUCCESS(status)) return status;

    PDEVICE_CONTEXT ctx = GetDeviceContext(device);
    RtlZeroMemory(&ctx->Ring, sizeof(ctx->Ring)); ctx->Ring.Head = -1;
    WDF_OBJECT_ATTRIBUTES lockAttr; WDF_OBJECT_ATTRIBUTES_INIT(&lockAttr);
    WdfSpinLockCreate(&lockAttr, &ctx->Ring.Lock);

    WDF_IO_QUEUE_CONFIG qcfg; WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&qcfg, WdfIoQueueDispatchParallel);
    qcfg.EvtIoDeviceControl = AppleMagic_EvtIoDeviceControl;
    qcfg.EvtIoInternalDeviceControl = AppleMagic_EvtIoInternalDeviceControl;
    qcfg.EvtIoStop = AppleMagic_EvtIoStop;
    status = WdfIoQueueCreate(device, &qcfg, WDF_NO_OBJECT_ATTRIBUTES, &ctx->IoctlQueue);
    if(!NT_SUCCESS(status)) return status;

    status = WdfDeviceCreateDeviceInterface(device, &GUID_DEVINTERFACE_APPLE_MAGIC_RAW, NULL);
    return status;
}

NTSTATUS AppleMagic_EvtPrepareHardware(WDFDEVICE Device, WDFCMRESLIST Raw, WDFCMRESLIST Trans){
    UNREFERENCED_PARAMETER(Device);UNREFERENCED_PARAMETER(Raw);UNREFERENCED_PARAMETER(Trans);return STATUS_SUCCESS;
}

VOID AppleMagic_ReadReportCompletion(WDFREQUEST Request, WDFIOTARGET Target, PWDF_REQUEST_COMPLETION_PARAMS Params, WDFCONTEXT Context){
    UNREFERENCED_PARAMETER(Target);UNREFERENCED_PARAMETER(Context);
    WdfRequestComplete(Request, Params->IoStatus.Status);
}

static VOID RingPush(PDEVICE_CONTEXT ctx, PUCHAR data, USHORT len){
    if(len>MAGIC_MAX_REPORT_SIZE) return; WdfSpinLockAcquire(ctx->Ring.Lock);
    LONG next = (ctx->Ring.Head+1)%MAGIC_RING_CAPACITY; RtlCopyMemory(ctx->Ring.Data[next], data, len); ctx->Ring.Lengths[next]=len; ctx->Ring.Head=next; WdfSpinLockRelease(ctx->Ring.Lock);
}

// Basic parser stub
BOOLEAN Magic_ParseMouseReport(const UCHAR* Report, USHORT Length, PMAGIC_PARSED_MOUSE_REPORT Parsed){
    if(!Report||!Parsed||Length<6) return FALSE; RtlZeroMemory(Parsed, sizeof(*Parsed));
    Parsed->ReportId = Report[0];
    Parsed->Buttons  = Report[1];
    Parsed->DeltaX   = (SHORT)((Report[2]<<8)|Report[3]);
    Parsed->DeltaY   = (SHORT)((Report[4]<<8)|Report[5]);
    Parsed->ContactCount = 0; return TRUE;
}

VOID AppleMagic_EvtIoInternalDeviceControl(WDFQUEUE Q, WDFREQUEST R, size_t OutLen, size_t InLen, ULONG Code){
    UNREFERENCED_PARAMETER(OutLen);UNREFERENCED_PARAMETER(InLen);WDFDEVICE dev = WdfIoQueueGetDevice(Q);
    if(Code==IOCTL_HID_READ_REPORT){
        WDF_REQUEST_SEND_OPTIONS opt; WDF_REQUEST_SEND_OPTIONS_INIT(&opt, WDF_REQUEST_SEND_OPTION_SEND_AND_FORGET);
        WdfRequestFormatRequestUsingCurrentType(R);
        WdfRequestSetCompletionRoutine(R, AppleMagic_ReadReportCompletion, dev);
        if(!WdfRequestSend(R, WdfDeviceGetIoTarget(dev), &opt)){
            NTSTATUS st = WdfRequestGetStatus(R); WdfRequestComplete(R, st);
        }
        return;
    }
    WDF_REQUEST_SEND_OPTIONS opt; WDF_REQUEST_SEND_OPTIONS_INIT(&opt, WDF_REQUEST_SEND_OPTION_SEND_AND_FORGET);
    WdfRequestFormatRequestUsingCurrentType(R);
    if(!WdfRequestSend(R, WdfDeviceGetIoTarget(dev), &opt)){
        NTSTATUS st = WdfRequestGetStatus(R); WdfRequestComplete(R, st);
    }
}

VOID AppleMagic_EvtIoDeviceControl(WDFQUEUE Q, WDFREQUEST R, size_t OutLen, size_t InLen, ULONG Code){
    UNREFERENCED_PARAMETER(InLen); WDFDEVICE dev = WdfIoQueueGetDevice(Q); PDEVICE_CONTEXT ctx = GetDeviceContext(dev);
    if(Code==IOCTL_APPLE_MAGIC_GET_LAST_REPORT || Code==IOCTL_APPLE_MAGIC_PARSE_LAST){
        PUCHAR buf; size_t len; if(!NT_SUCCESS(WdfRequestRetrieveOutputBuffer(R, OutLen, (PVOID*)&buf, &len))){WdfRequestComplete(R, STATUS_INVALID_PARAMETER);return;}
        USHORT copy=0; UCHAR tmp[MAGIC_MAX_REPORT_SIZE]; USHORT tlen=0; WdfSpinLockAcquire(ctx->Ring.Lock);
        if(ctx->Ring.Head>=0){ LONG idx=ctx->Ring.Head; tlen=ctx->Ring.Lengths[idx]; if(tlen && tlen<=MAGIC_MAX_REPORT_SIZE){ RtlCopyMemory(tmp, ctx->Ring.Data[idx], tlen);} else tlen=0; }
        WdfSpinLockRelease(ctx->Ring.Lock);
        if(Code==IOCTL_APPLE_MAGIC_GET_LAST_REPORT){
            if(tlen && len>=tlen){ RtlCopyMemory(buf, tmp, tlen); copy=tlen; }
            WdfRequestCompleteWithInformation(R, STATUS_SUCCESS, copy); return;
        }else{ // parse
            MAGIC_PARSED_MOUSE_REPORT parsed; BOOLEAN ok = Magic_ParseMouseReport(tmp, tlen, &parsed);
            if(ok && len>=sizeof(parsed)){ RtlCopyMemory(buf, &parsed, sizeof(parsed)); copy = (USHORT)sizeof(parsed);} 
            WdfRequestCompleteWithInformation(R, ok?STATUS_SUCCESS:STATUS_DATA_ERROR, copy); return; }
    }
    WdfRequestComplete(R, STATUS_INVALID_DEVICE_REQUEST);
}

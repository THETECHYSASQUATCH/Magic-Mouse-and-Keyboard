#include <windows.h>
#include <wrl.h>
#include <wdf.h>
#include <hidclass.h>
#include "..\..\Common\include\IoctlContract.h"
using namespace Microsoft::WRL;

extern "C" DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_DEVICE_ADD EvtDeviceAdd;
EVT_WDF_IO_QUEUE_IO_DEVICE_CONTROL EvtIoDeviceControl;

static NTSTATUS CreateDefaultQueue(_In_ WDFDEVICE device);

extern "C" NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
    WDF_DRIVER_CONFIG config;
    WDF_DRIVER_CONFIG_INIT(&config, EvtDeviceAdd);
    return WdfDriverCreate(DriverObject, RegistryPath, WDF_NO_OBJECT_ATTRIBUTES, &config, WDF_NO_HANDLE);
}

NTSTATUS EvtDeviceAdd(_In_ WDFDRIVER Driver, _Inout_ PWDFDEVICE_INIT DeviceInit)
{
    UNREFERENCED_PARAMETER(Driver);
    WdfFdoInitSetFilter(DeviceInit);

    WDFDEVICE device;
    NTSTATUS status = WdfDeviceCreate(&DeviceInit, WDF_NO_OBJECT_ATTRIBUTES, &device);
    if (!NT_SUCCESS(status)) return status;

    status = CreateDefaultQueue(device);
    if (!NT_SUCCESS(status)) return status;

    // TODO: open lower HID PDO and start continuous reader for IOCTL_HID_READ_REPORT
    return STATUS_SUCCESS;
}

static NTSTATUS CreateDefaultQueue(_In_ WDFDEVICE device)
{
    WDF_IO_QUEUE_CONFIG q;
    WDF_IO_QUEUE_CONFIG_INIT_DEFAULT_QUEUE(&q, WdfIoQueueDispatchParallel);
    q.EvtIoDeviceControl = EvtIoDeviceControl;

    WDFQUEUE queue;
    return WdfIoQueueCreate(device, &q, WDF_NO_OBJECT_ATTRIBUTES, &queue);
}

void EvtIoDeviceControl(_In_ WDFQUEUE Queue, _In_ WDFREQUEST Request, _In_ size_t OutLen, _In_ size_t InLen, _In_ ULONG Ioctl)
{
    UNREFERENCED_PARAMETER(Queue);
    UNREFERENCED_PARAMETER(OutLen);
    UNREFERENCED_PARAMETER(InLen);

    NTSTATUS status = STATUS_INVALID_DEVICE_REQUEST;
    if (Ioctl == APPLEINPUT_IOCTL_SET_CONFIG) {
        status = STATUS_SUCCESS;
    } else if (Ioctl == APPLEINPUT_IOCTL_UPDATE_BATTERY) {
        status = STATUS_SUCCESS;
    }
    WdfRequestComplete(Request, status);
}